#    -*- mode: org -*-
#+FILETAGS: TIL
#+TITLE: Today I Learned
#+AUTHOR: Mark Costello

This is a record of things I learned that I want to remember. Organized mainly around various subject matter headings.

* Emacs
** Evil Mode Substitution - Confirm Flag
<2017-03-17 Fri>

Adding ~c~ to the end of an ~evil-mode~ substitution flag will invoke a "confirm" workflow that allows choosing which substitutions should be performed

#+BEGIN_SRC
  :s/foo/bar/gc
#+END_SRC

* Git
** Show a list of local branches sorted by last commmit date
<2017-03-16 Thu>
#+BEGIN_SRC sh
  git for-each-ref --sort=-committerdate refs/heads/ --format='%(committerdate:short) %(authorname) %(refname:short)'
#+END_SRC
Note: by changing the ~--sort~ flag, you can order things differently.

** Rebasing: The meaning of "theirs" vs "ours"
<2017-03-16 Thu>

When *merging* (~git merge~), the ~ours~ branch refers to the branch being merged into, and ~theirs~ refers to the branch being merged.
#+BEGIN_SRC sh
  git checkout feature-branch
  git merge master
#+END_SRC
In the above, ~ours~ is ~feature-branch~ and ~theirs~ is ~master~.

When *rebasing*, this semantic is essentially swapped, as the work on hold is being replayed onto the main history.

#+BEGIN_SRC sh
  git checkout feature-branch
  git rebase master
#+END_SRC

In the above, ~ours~ is ~master~ and ~theirs~ is ~feature-branch~.

So, if we wanted to resolve conflicts up front, we can use the ~-Xours~ or ~-Xtheirs~ to resolve the conflicts up front.

~git rebase -Xours master~: This resolves the conflicts in favor of selecting the changes in the master branch (the canonical work from the main history).
~git rebase -Xtheirs master~: This resolves the conflicts in favor of selecting the changes in the ~feature-branch~ branch (the work on hold).

* Go
** Get the reflect.Type of a type without instantiating it
<2017-03-16 Thu>

In many cases, getting the ~reflect.Type~ of a type requires calling ~reflect.TypeOf~ with an instantiated variable.

#+BEGIN_SRC go
  import "reflect"

  type reflectableType struct{}

  // Get the reflect.Type of the pointer to the type
  t1 := reflect.TypeOf(&reflectableType{})

  // Get the reflect.Type of the element
  t2 := t1.Elem()
#+END_SRC

Though slightly contrived, what if we don't want to instantiate the type to be reflected?

#+BEGIN_SRC go
  import "reflect"

  type reflectableType struct{}

  // Get the reflect.Type of the pointer to the type
  t1 := reflect.TypeOf((*reflectableType)(nil))

  // Get the reflect.Type of the element
  t2 := t1.Elem()
#+END_SRC

In both cases above:

- ~t1~ is the ~reflect.Type~ of ~*reflectableType~
- ~t2~ is the ~reflect.Type~ of ~reflectableType~

** Making Rate Limited Calls to an API
<2017-03-20 Mon>

Github's API rate limits calls to 5000 per/hour. Using a ~time.Ticker~ can allow us to remain within these limits

#+BEGIN_SRC go
  const ghRate = 720*time.Millisecond // 5000/3600

  ticker := time.NewTicker(ghRate)

  // Call <-ticker.C before every call to the github API
  <-ticker.C // this will block until the time has ticked
  github.ListIssues()
#+END_SRC

** Deleting an installed package
<2017-03-20 Mon>

~go clean -i importpath...~ will remove all archive files and executable binaries for a package.

for example: ~go clean -i github.com/foo/bar...~ removes all artifacts for the ~github.com/foo/bar~ package.

*Note:* Include the ~...~ on the importpath. If a package includes an executable ~go clean -i~ will only remove that and not archive files for subpackages.

* Makefile
** Silence command printing
<2017-03-16 Thu>

If we have the following:
#+BEGIN_SRC makefile
  target:
	  echo "running target"
#+END_SRC

It'll print out the command, and the output of the command:
#+BEGIN_SRC
$ make target
echo "running target"
running target
#+END_SRC

To silence this, place ~@~ immediately preceding the the command
#+BEGIN_SRC makefile
  target:
	  @echo "running target"
#+END_SRC
Invoking this:
#+BEGIN_SRC
$ make target
running target
#+END_SRC

** Call a Makefile target within another Makefile target
<2017-03-16 Thu>

#+BEGIN_SRC makefile
  other-target:
	  @echo "other target"

  target:
	  @$(MAKE) other-target
#+END_SRC
Calling ~make target~ will invoke ~other-target~.

This is useful in the case where there are a list of prerequisites, but one prerequisite is dependent on the artifacts created by another prerequisite.
#+BEGIN_SRC makefile
  target: a b c
#+END_SRC

If, above, ~c~ depends on a directory created by ~a~, ~c~ won't run. We can do the following instead:
#+BEGIN_SRC makefile
  target:
	  @$(MAKE) a
	  @$(MAKE) b
	  @$(MAKE) c
#+END_SRC
