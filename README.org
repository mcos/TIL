#    -*- mode: org -*-
#+FILETAGS: TIL
#+TITLE: Today I Learned
#+AUTHOR: Mark Costello

This is a record of things I learned that I want to remember. Organized mainly around various subject matter headings.

* Git
** Show a list of local branches sorted by last commmit date
<2017-03-16 Thu>
#+BEGIN_SRC sh
  git for-each-ref --sort=-committerdate refs/heads/ --format='%(committerdate:short) %(authorname) %(refname:short)'
#+END_SRC
Note: by changing the ~--sort~ flag, you can order things differently.

** Rebasing: The meaning of "theirs" vs "ours"
<2017-03-16 Thu>

When *merging* (~git merge~), the ~ours~ branch refers to the branch being merged into, and ~theirs~ refers to the branch being merged.
#+BEGIN_SRC sh
  git checkout feature-branch
  git merge master
#+END_SRC
In the above, ~ours~ is ~feature-branch~ and ~theirs~ is ~master~.

When *rebasing*, this semantic is essentially swapped, as the work on hold is being replayed onto the main history.

#+BEGIN_SRC sh
  git checkout feature-branch
  git rebase master
#+END_SRC

In the above, ~ours~ is ~master~ and ~theirs~ is ~feature-branch~.

So, if we wanted to resolve conflicts up front, we can use the ~-Xours~ or ~-Xtheirs~ to resolve the conflicts up front.

~git rebase -Xours master~: This resolves the conflicts in favor of selecting the changes in the master branch (the canonical work from the main history).
~git rebase -Xtheirs master~: This resolves the conflicts in favor of selecting the changes in the ~feature-branch~ branch (the work on hold).

* Go
** Get the reflect.Type of a type without instantiating it
<2017-03-16 Thu>

In many cases, getting the ~reflect.Type~ of a type requires calling ~reflect.TypeOf~ with an instantiated variable.

#+BEGIN_SRC go
  import "reflect"

  type reflectableType struct{}

  // Get the reflect.Type of the pointer to the type
  t1 := reflect.TypeOf(&reflectableType{})

  // Get the reflect.Type of the element
  t2 := t1.Elem()
#+END_SRC

Though slightly contrived, what if we don't want to instantiate the type to be reflected?

#+BEGIN_SRC go
  import "reflect"

  type reflectableType struct{}

  // Get the reflect.Type of the pointer to the type
  t1 := reflect.TypeOf((*reflectableType)(nil))

  // Get the reflect.Type of the element
  t2 := t1.Elem()
#+END_SRC

In both cases above:

- ~t1~ is the ~reflect.Type~ of ~*reflectableType~
- ~t2~ is the ~reflect.Type~ of ~reflectableType~

* Makefile
** Silence command printing
<2017-03-16 Thu>

If we have the following:
#+BEGIN_SRC makefile
  target:
	  echo "running target"
#+END_SRC

It'll print out the command, and the output of the command:
#+BEGIN_SRC
$ make target
echo "running target"
running target
#+END_SRC

To silence this, place ~@~ immediately preceding the the command
#+BEGIN_SRC makefile
  target:
	  @echo "running target"
#+END_SRC
Invoking this:
#+BEGIN_SRC
$ make target
running target
#+END_SRC

** Call a Makefile target within another Makefile target
<2017-03-16 Thu>

#+BEGIN_SRC makefile
  other-target:
	  @echo "other target"

  target:
	  @$(MAKE) other-target
#+END_SRC
Calling ~make target~ will invoke ~other-target~.

This is useful in the case where there are a list of prerequisites, but one prerequisite is dependent on the artifacts created by another prerequisite.
#+BEGIN_SRC makefile
  target: a b c
#+END_SRC

If, above, ~c~ depends on a directory created by ~a~, ~c~ won't run. We can do the following instead:
#+BEGIN_SRC makefile
  target:
	  @$(MAKE) a
	  @$(MAKE) b
	  @$(MAKE) c
#+END_SRC
